# NGL Bytecode 3.0 Data Containers

from copy import deepcopy

# Simple Types

# TODO: add flag for 'system val' and 'global'
class Value:
    strrep = 'null'
    sub = None # holds any subtype
    data = None # holds any extra data
    def __init__(self,const=False):
        self.const = const
    def clone(self):
        return deepcopy(self)
    def __eq__(self,other):
        return type(self) == type(other) or type(other) == Ref
    def __str__(self):
        return '{0}{1}{2}{3}'.format('const ' if self.const == True else '', self.strrep, ' of {0}'.format(self.sub.strrep) if self.sub != None else '', ' ({0})'.format(self.data) if self.data != None else '')

class Int(Value):
    # Represents an integer
    strrep = 'int'

class Float(Value):
    # Represents a floating point number
    strrep = 'float'

class Str(Value):
    # Represents a string
    strrep = 'str'

class Bool(Value):
    # Represents a boolean
    strrep = 'bool'

class Func(Value):
    # Represents a function: can be converted to the full runtime version
    strrep = 'func'
    def __init__(self,data=None,const=False):
        super().__init__(const)
        self.data = data # represents file name

class Lab(Value):
    # Represents a label: can be converted to the full runtime version
    strrep = 'label'
    def __init__(self,data=None,const=False):
        super().__init__(const)
        self.data = data # represents jump destination

class Arr(Value):
    strrep = 'array'
    def __init__(self,subtyp,const=False):
        super().__init__(const)
        self.sub = subtyp
    def __eq__(self,other):
        if type(self) == type(other):
            return self.sub == other.sub
        return False

class Lst(Value):
    strrep = 'list'
    def __init__(self,const=False):
        super().__init__(const)
    def __eq__(self,other):
        return type(self) == type(other)

class Ref(Value):
    # Represents a variable or function call where the type is not know at compile time
    strrep = 'ref'

    def __init__(self,typ,data=None,const=False):
        self.data = data
        self.const = const

        if typ == 'input':      self.sub = Ref.Input()
        elif typ == 'ident':    self.sub = Ref.Ident()
        elif typ == 'list':     self.sub = Ref.List()
        elif typ == 'spc':      self.sub = Ref.Special()
        elif typ == 'func':      self.sub = Ref.Function()
        elif typ == 'null':      self.sub = Ref.Error()
        else:                   raise Exception('unknown ref type')
    def __eq__(self,other):
        if type(other) in set({Int,Float,Str,Bool,Func,Lab}) or type(other) == Ref:
            return True
        return False

    class Input: # from `in` statement
        strrep = 'input'
    class Ident: # from an unresolved identifier call -> should not exist when interpretation begins
        strrep = 'ident'
    class List: # contents of a list
        strrep = 'auto'
    class Special: # an identifier which has special system meaning / varying type
        strrep = 'sys'
    class Function: # a function return
        strrep = 'func'
    class Error: # an identifier only generated by errors
        strrep = 'null'


# Runtime Types

class Const:
    def __init__(self,typ,val=None):
        self.type = typ
        self.val = val
    def __eq__(self,other):
        if other in SIMPLE:
            return self.type == other.type and self.val == other.val
        return False
    def __str__(self):
        return 'Const {0}::{1}'.format(self.val,self.type)

class Var:
    def __init__(self,typ,val=None):
        self.type = typ
        self.val = val
    def __eq__(self,other):
        if other in SIMPLE:
            return self.type == other.type and self.val == other.val
        return False
    def __str__(self):
        return 'Var {0}::{1}'.format(self.val,self.type)

class Array:
    def __init__(self,typ,val=None):
        self.type = typ
        self.val = val
    def __eq__(self,other):
        if other == None: return False
        return self.type == other.type and self.val == other.val
    def __str__(self):
        return 'Array of {0}::{1}'.format(self.type,self.val) if self.val != None else 'Array of {0}'.format(self.type)

class List:
    def __init__(self,typ,val=None):
        self.type = typ
        self.val = val
    def __eq__(self,other):
        if other == None: return False
        return self.type == other.type and self.val == other.val
    def __str__(self):
        return 'List of {0}::{1}'.format(self.type,self.val) if self.val != None else 'List of {0}'.format(self.type)

class Function:
    # A callable function (must be included)
    #fields: name, filename, param number
    def __init__(self,fname):
        self.val = fname
    def __eq__(self,other):
        if other in COMPLEX:
            return self.type == other.type and self.value == other.value
        return False
    def __str__(self):
        return 'Func in {0}'.format(self.val)

class Label:
    # A representation of a jumpable line
    def __init__(self,value):
        # self.type = name # Label name
        self.val = value # jump destination
    def __eq__(self,other):
        return False
    def __str__(self):
        # return 'Label {0} at {1}'.format(self.type,self.val+1) # add 1 to line up with text editor
        return 'Label at {0}'.format(self.val+1) # add 1 to line up with text editor

class Error:
    # A representation of an exception
    pass


# (TBD) Non constant value (like from a variable)
# class Value:
#     def __init__(self,typ,value):
#         self.type = typ
#         self.value = value
#
#     def __eq__(self,other):
#         if type(other) == type(self):
#             return self.type == other.type and self.value = other.value
#         return False

# Represents a value constant
class Constant:
    def __init__(self, typ, value):
        self.type = typ
        self.value = value

    def __str__(self):
        if type(self.type) == Float:    typ = 'float'
        elif type(self.type) == Int:    typ = 'int'
        elif type(self.type) == Str:    typ = 'str'
        else:                           typ = 'bool'
        return 'Const {0}::{1}'.format(self.value,typ)


    def __eq__(self,other):
        if type(other) == type(self):
            return self.type == other.type and self.value == other.value
        return False

    def __ne__(self,other):
        return not self == other

# Represents a variable reference (used exclusively within the symbol table)
class VariableValue(Constant):
    def __init__(self, typ, value=None):
        super().__init__(typ,None)
        if value != None:
            self.setValue(value)

    def __str__(self):
        if type(self.type) == Float:    typ = 'float'
        elif type(self.type) == Int:    typ = 'int'
        elif type(self.type) == Str:    typ = 'str'
        else:                           typ = 'bool'
        return 'Var {0}::{1}'.format(self.value,typ)

    def setValue(self,value):
        self.value = value

# Represents a constant collection
class ConstantArray:
    def __init__(self, typ, value):
        self.type = typ
        self.value = tuple(value)

    def __str__(self):
        if type(self.type) == Float:    typ = 'float'
        elif type(self.type) == Int:    typ = 'int'
        elif type(self.type) == Str:    typ = 'str'
        else:                           typ = 'bool'
        return 'Array {0}::{1}'.format(self.value,typ)

    @property
    def len(self):
        return len(self.value)

    def __eq__(self,other):
        if type(other) == type(self) and self.type == other.type and len(self.value) == len(other.value):
            for i in range(len(self.value)):
                if self.value[i] != other.value[i]: return False
            return True
        return False

    def __ne__(self,other):
        return not self == other

# Represents a variable collection (used exclusively within the symbol table)
class VariableArray(Array):
    def __init__(self, typ, value):
        super().__init__(typ,value)
        self.value = list(self.value)

    def __str__(self):
        if self.type == Int:  typ = 'float'
        elif self.type == Int:  typ = 'int'
        elif self.type == Str:  typ = 'str'
        else:                   typ = 'bool'
        return 'List {0}::{1}'.format(self.value,typ)

    def setValue(self,value,index=None):
        if index == None:
            self.value = list(value)
        else:
            self.value[index] = value


if __name__ == '__main__':
    pass
